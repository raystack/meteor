// Code generated by mockery v2.32.4. DO NOT EDIT.

package mocks

import (
	context "context"

	merlin "github.com/raystack/meteor/plugins/extractors/merlin/internal/merlin"

	mock "github.com/stretchr/testify/mock"
)

// MerlinClient is an autogenerated mock type for the Client type
type MerlinClient struct {
	mock.Mock
}

type MerlinClient_Expecter struct {
	mock *mock.Mock
}

func (_m *MerlinClient) EXPECT() *MerlinClient_Expecter {
	return &MerlinClient_Expecter{mock: &_m.Mock}
}

// ModelVersion provides a mock function with given fields: ctx, modelID, versionID
func (_m *MerlinClient) ModelVersion(ctx context.Context, modelID int64, versionID int64) (merlin.ModelVersion, error) {
	ret := _m.Called(ctx, modelID, versionID)

	var r0 merlin.ModelVersion
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64) (merlin.ModelVersion, error)); ok {
		return rf(ctx, modelID, versionID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64) merlin.ModelVersion); ok {
		r0 = rf(ctx, modelID, versionID)
	} else {
		r0 = ret.Get(0).(merlin.ModelVersion)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, int64) error); ok {
		r1 = rf(ctx, modelID, versionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MerlinClient_ModelVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModelVersion'
type MerlinClient_ModelVersion_Call struct {
	*mock.Call
}

// ModelVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - modelID int64
//   - versionID int64
func (_e *MerlinClient_Expecter) ModelVersion(ctx interface{}, modelID interface{}, versionID interface{}) *MerlinClient_ModelVersion_Call {
	return &MerlinClient_ModelVersion_Call{Call: _e.mock.On("ModelVersion", ctx, modelID, versionID)}
}

func (_c *MerlinClient_ModelVersion_Call) Run(run func(ctx context.Context, modelID int64, versionID int64)) *MerlinClient_ModelVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(int64))
	})
	return _c
}

func (_c *MerlinClient_ModelVersion_Call) Return(_a0 merlin.ModelVersion, _a1 error) *MerlinClient_ModelVersion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MerlinClient_ModelVersion_Call) RunAndReturn(run func(context.Context, int64, int64) (merlin.ModelVersion, error)) *MerlinClient_ModelVersion_Call {
	_c.Call.Return(run)
	return _c
}

// Models provides a mock function with given fields: ctx, projectID
func (_m *MerlinClient) Models(ctx context.Context, projectID int64) ([]merlin.Model, error) {
	ret := _m.Called(ctx, projectID)

	var r0 []merlin.Model
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) ([]merlin.Model, error)); ok {
		return rf(ctx, projectID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) []merlin.Model); ok {
		r0 = rf(ctx, projectID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]merlin.Model)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, projectID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MerlinClient_Models_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Models'
type MerlinClient_Models_Call struct {
	*mock.Call
}

// Models is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID int64
func (_e *MerlinClient_Expecter) Models(ctx interface{}, projectID interface{}) *MerlinClient_Models_Call {
	return &MerlinClient_Models_Call{Call: _e.mock.On("Models", ctx, projectID)}
}

func (_c *MerlinClient_Models_Call) Run(run func(ctx context.Context, projectID int64)) *MerlinClient_Models_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *MerlinClient_Models_Call) Return(_a0 []merlin.Model, _a1 error) *MerlinClient_Models_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MerlinClient_Models_Call) RunAndReturn(run func(context.Context, int64) ([]merlin.Model, error)) *MerlinClient_Models_Call {
	_c.Call.Return(run)
	return _c
}

// Projects provides a mock function with given fields: ctx
func (_m *MerlinClient) Projects(ctx context.Context) ([]merlin.Project, error) {
	ret := _m.Called(ctx)

	var r0 []merlin.Project
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]merlin.Project, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []merlin.Project); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]merlin.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MerlinClient_Projects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Projects'
type MerlinClient_Projects_Call struct {
	*mock.Call
}

// Projects is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MerlinClient_Expecter) Projects(ctx interface{}) *MerlinClient_Projects_Call {
	return &MerlinClient_Projects_Call{Call: _e.mock.On("Projects", ctx)}
}

func (_c *MerlinClient_Projects_Call) Run(run func(ctx context.Context)) *MerlinClient_Projects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MerlinClient_Projects_Call) Return(_a0 []merlin.Project, _a1 error) *MerlinClient_Projects_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MerlinClient_Projects_Call) RunAndReturn(run func(context.Context) ([]merlin.Project, error)) *MerlinClient_Projects_Call {
	_c.Call.Return(run)
	return _c
}

// NewMerlinClient creates a new instance of MerlinClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMerlinClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *MerlinClient {
	mock := &MerlinClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
